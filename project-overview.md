# Ten10: פלטפורמת ניהול פיננסי למעקב הכנסות, הוצאות ומעשרות

## מנקודת מבט של מנהל מוצר

Ten10 היא פלטפורמת קוד פתוח המסייעת במשימה המורכבת של ניהול פיננסי ביתי, עם דגש ייחודי על חישוב מעשר (10% מההכנסות המיועדים לצדקה)[^1]. המערכת מיועדת לשתי קבוצות עיקריות של משתמשים:

- **משתמשים מקוונים (Web)** – אפליקציית ווב (React) המתארחת בענן, עם אחסון נתונים בענן Supabase (מסד נתוני Postgres) וניהול משתמשים באמצעות מנגנון ההזדהות של Supabase[^2][^3].
- **משתמשים לא מקוונים (Desktop)** – אפליקציית דסקטופ (מבוססת Tauri) שניתן להפעילה ללא חיבור אינטרנט, עם אחסון הנתונים מקומית בקובץ SQLite. לגרסה זו אין צורך בהרשמה או כניסה לחשבון – הנתונים נשמרים מקומית בלבד[^4].

חשוב להדגיש: כל משתמש עובד או בסביבת הענן או בסביבת הדסקטופ – כרגע אין סנכרון אוטומטי בזמן אמת ביניהן, אך קיים מנגנון **סנכרון ידני** באמצעות ייבוא וייצוא נתונים. המשתמש יכול לייצא את כל הנתונים מקובץ JSON מהדסקטופ ולייבא אותם לווב, ולהפך – מה שמאפשר מעבר בין הפלטפורמות ושמירה על רצף הנתונים. בכך Ten10 פותרת בעיה כפולה: היא מאפשרת גמישות למי שרוצה פתרון מודרני בענן עם גיבוי ונגישות מכל מקום, ובמקביל נותנת מענה לאוכלוסיות הזקוקות למערכת אופליין עקב העדפות פרטיות או היעדר חיבור רציף לאינטרנט. המוצר מספק למשתמשים תמונה ברורה ועדכנית של מצבם הכלכלי – הכנסות מול הוצאות – ובעיקר כמה מעשר הם נדרשים להפריש בכל רגע נתון, ובכך מפשט קבלת החלטות פיננסיות ועמידה במצוות מעשר בצורה מסודרת.

### מאפיינים מרכזיים (Features)

Ten10 מציעה מגוון פיצ'רים כדי לענות על צרכי המשתמשים:

- **לוח מחוונים (Dashboard)**: מסך מרכזי המציג מדדים חיוניים כמו סך ההכנסות, סך ההוצאות, סך התרומות (צדקה) ויתרת המעשר הנדרשת לתשלום[^1][^6]. כך המשתמש מקבל במבט מהיר תמונת מצב פיננסית, כולל כמה עליו עוד להפריש למעשר.

- **ניהול עסקאות אחוד**: המערכת מגדירה סוג מידע אחד Unified Transaction לכל האירועים הפיננסיים – הכנסה, הוצאה או תרומה – עם שדות דוגמת תאריך, סכום, מטבע, תיאור וסוג העסקה[^7][^8]. גישה מאוחדת זו מפשטת את הזנת הנתונים ומאפשרת חישוב אחיד של יתרת המעשר.

- **חישוב דינמי של מעשרות**: אין צורך בחישוב ידני – האפליקציה מחשבת באופן אוטומטי את יתרת המעשר הנדרשת על סמך רשימת העסקאות שהוזנו. למשל, הוספת הכנסה מגדילה את יתרת החוב למעשר (10% מההכנסה, או 20% במקרה של סימון "חומש"), בעוד שהזנת תרומה מקטינה את היתרה (כל שקל תרומה מקזז שקל מהחוב)[^7][^9]. החישוב מתעדכן מיידית בכל שינוי, ומוצג באופן ברור בלוח המחוונים.

- **הזנת נתונים קלה וטבעית**: הוספת הכנסות, הוצאות ותרומות מתבצעת באמצעות טפסים אינטואיטיביים בתוך האפליקציה[^1][^6]. המשתמש מזין פרטי עסקה (סכום, תאריך, קטגוריה, תיאור וכו'), והמערכת מטפלת בשמירה ובחישוב ברקע באופן שקוף.

- **הוראות קבע (Recurring Transactions)**: המערכת תומכת בהגדרת הוראות קבע לתנועות חוזרות, כגון צדקה חודשית, שכר דירה או הכנסה קבועה. המשתמש מגדיר תבנית (template) עם פרטי התנועה, תדירות (חודשית/שבועית/יומית/שנתית), יום בחודש לביצוע, תאריך התחלה ואפשרות לסיום. המערכת מייצרת אוטומטית תנועות חדשות על בסיס התבנית:

  - **בווב**: CRON Job רץ בסופבייס כל לילה, בודק אילו הוראות קבע הגיע תורן, ומייצר תנועות חדשות בטבלת התנועות (רק אם הן עדיין לא קיימות, כדי למנוע כפילויות).
  - **בדסקטופ**: תהליך שרת רץ בעת פתיחת האפליקציה, מחשב אילו תנועות היו אמורות להיות מיום הריצה האחרון ועד היום, ומוסיף אותן ל-SQLite. כך גם אם המחשב היה כבוי שבועיים, כשפותחים – ההוראות קבע "משלימות פערים".

  כל תנועה שנוצרה מהוראת קבע מקושרת לתבנית המקורית דרך `source_recurring_id`, מה שמאפשר מעקב אחר ביצועים ומניעת כפילויות. זהו פיצ'ר מורכב מבחינה ארכיטקטונית, המשלב תבניות (templates) עם תהליכי materialization אוטומטיים.

- **כלים לניתוח נתונים**: העסקאות שהוזנו מוצגות בטבלאות וגרפים, עם אפשרויות סינון ומיון מתקדמות. המשתמש יכול לחפש עסקה לפי מלל חופשי, לסנן לפי טווח תאריכים או סוג עסקה, ולמיין לפי עמודות (תאריך, סכום, סוג)[^6][^10]. בנוסף, קיימת יכולת לייצא את הנתונים המסוננים לקובצי CSV/Excel/PDF להמשך עיבוד או שיתוף[^10].

- **ייבוא וייצוא נתונים וסנכרון ידני**: שתי הפלטפורמות (ווב ודסקטופ) תומכות בייבוא וייצוא נתונים לקובץ JSON, מה שמאפשר **סנכרון ידני** בין הפלטפורמות. המשתמש יכול לייצא את כל העסקאות מהדסקטופ ולייבא אותן לווב, ולהפך – מה שמאפשר מעבר בין הפלטפורמות ושמירה על רצף הנתונים. בנוסף, המשתמש האופליין יכול לגבות את המידע האישי שלו או להעבירו ממחשב למחשב. הפיצ'ר זמין בשתי הפלטפורמות ומשתמש בפורמט JSON אחיד[^6][^11].

- **רב-לשוניות ועברית מלאה**: הממשק תומך מתחילתו בשפות עברית (ברירת מחדל) וגם אנגלית, כולל תמיכה בכיווניות ימין-לשמאל עבור עברית[^13][^14]. המשתמש יכול להחליף שפה בהגדרות, וכל הטקסטים מתורגמים בהתאם (הטקסטים מנוהלים בקובצי תרגום נפרדים).

- **מצב כהה/בהיר והתאמה חזותית**: האפליקציה מציעה Theme כהה ובהיר להעדפת המשתמש, וממשק רספונסיבי שמתאים גם לנייד, גם לטאבלט וגם לשולחן עבודה[^13][^15]. העיצוב המודרני בנוי עם ספריית רכיבי UI מקצועית (מבוססת Radix UI) ותבניות עיצוב Tailwind CSS, מה שמבטיח ממשק חלק וברור. העיצוב פשוט ואינטואיטיבי, עם אנימציות עדינות (fade-ins, transitions על hover, מצבי טעינה) – לא "קרקס", אלא עדין ומקצועי. האנימציות מבוצעות באמצעות CSS transitions ו-Tailwind utilities, מה שמבטיח ביצועים טובים וחוויית משתמש חלקה.

- **תמיכה במטבעות שונים**: כבר כעת יש תמיכה במטבעות שקל חדש (₪), דולר ($) ו-אירו (€), כך שהמשתמש יכול לנהל עסקאות במטבע הרלוונטי עבורו[^13]. שערי חליפין מוצגים למשתמש **לתצוגה בלבד** – אין המרת מטבעות אמיתית, והחישובים נשארים במטבע שבו הוזנה כל תנועה. זהו בחירה מודעת בגלל המורכבות בשמירת שערי חליפין לאורך זמן, במיוחד באפליקציה שעובדת גם אופליין. אם יהיה ביקוש משתמשים בעתיד, ניתן לפתח פיצ'ר המרת מטבעות מלא.

- **מידע הלכתי ועדכוני מערכת**: עבור משתמשים מהמגזר הדתי, קיימת עמוד מידע "הלכות מעשר" המציג הסבר על מצוות המעשר ודגשים הלכתיים[^16]. חשוב להדגיש שכל מנגנון ההלכה והחישובים נבנה **ביחד עם רבנים** (למשל ממכון תורת האדם), כולל **הגהה, בדיקה וכתיבת נוסחים הלכתיים**, ויש גם **הסכמות/המלצות רשמיות** על המוצר. כמו כן, מסך "אודות" ו"הגדרות" זמינים, ובגרסת הווב יש גם עמוד פרופיל משתמש (לניהול חשבון)[^16]. המערכת אף יודעת לשלוח תזכורות:

  - **בגירסת הווב**: אימייל חודשי אוטומטי למשתמש (באמצעות AWS SES דרך Cloud Function של Supabase). המיילים נשלחים בימים קבועים בחודש (1, 5, 10, 15, 20, 25) לפי העדפת המשתמש, עם התחשבות בשבת (לא נשלחים בשבת). תוכן המייל מותאם אישית לפי יתרת המעשר:
    - **יתרה חיובית**: "נותר לך X ₪ לתרומה" – עם רקע צהוב ועידוד לתרום
    - **יתרה שלילית**: "מצוין! תרמת יותר מהנדרש ב-X ₪" – עם רקע ירוק
    - **יתרה אפס**: "אתה בדיוק ביעד!" – עם רקע ירוק
      המיילים כוללים כותרת בעברית, גוף מפורט עם עדכון יתרת המעשר, רשימת תזכורות (הכנסות, הוצאות, תרומות), קישור לאפליקציה, ואפשרות ביטול הרשמה. כל המיילים תומכים בעברית RTL מלאה עם עיצוב HTML מותאם[^17].
  - **בדסקטופ**: התראה במחשב (Native Notification) בעת פתיחת האפליקציה, כשניתן גם להגדיר שהאפליקציה תופעל אוטומטית בעת עליית המחשב כדי לא להחמיץ את התזכורת[^18].

- **עדכונים אוטומטיים (דסקטופ)**: למרות אופיו הלא-מקוון, קל מאוד לשמור את גרסת הדסקטופ מעודכנת. Ten10 כולל מנגנון Auto-Update: האפליקציה בודקת בתקופות קבועות אם יצאה גרסה חדשה ב-GitHub, ומורידה ומתקינה אותה אוטומטית (באמצעות פלאגין העדכונים של Tauri)[^19]. ישנה אף אפשרות יזומה בתפריט ההגדרות "בדוק עדכון", ומערכת CI אוטומטית יוצרת חבילות התקנה ומעלה אותן ל-GitHub Releases עם כל גרסת תוכנה חדשה. יכולת זו מבטיחה שגם משתמש אופליין נהנה משיפורים ותיקונים ללא מאמץ.

- **תמיכה במובייל – PWA ו-TWA**: ה-Web App של Ten10 בנוי כ-PWA (Progressive Web App) מלא עם manifest ו-service worker, מה שמאפשר התקנה על מכשירים ניידים. בנוסף, קיימת גם **TWA (Trusted Web Activity)** שנבנתה עם Bubblewrap לאנדרואיד – זה מאפשר לעטוף את ה-PWA כאפליקציה "כמעט-נייטיבית" לאנדרואיד, עם אייקון, Splash screen וכו'. הפרויקט TWA קיים ומוכן, אך עדיין לא שוחרר בפועל ל-Play Store. זהו חלק מגרסת הווב, ומשתמש באותו בסיס קוד.

### פיצ'רים עתידיים (Roadmap)

Ten10 היא פלטפורמה מתפתחת, והצוות שוקד על הרחבת היכולות בהתאם לצרכי המשתמשים. להלן פיצ'רים מתוכננים לעתיד:

#### 1. שאל את הרב – ייעוץ הלכתי משולב

פיצ'ר שיאפשר למשתמשים לשלוח שאלות הלכתיות ישירות מהאפליקציה לרבנים מוסמכים. המשתמש יוכל לשאול שאלות ספציפיות על מצבו הפיננסי (למשל: "האם הכנסה זו חייבת במעשר?" או "מה הדין עם החזר מס?") ולקבל תשובות מקצועיות. הפיצ'ר יכלול:

- ממשק נוח לשליחת שאלות
- חיבור לרבנים מוסמכים (למשל ממכון תורת האדם)
- מעקב אחר שאלות ותשובות
- אפשרות לשמור תשובות רלוונטיות לשאלות חוזרות

#### 2. שילוב כלי AI – אוטומציה וסיוע חכם

שילוב טכנולוגיות AI כדי להפוך את ניהול הכספים לחכם ונוח יותר:

- **חילוץ טרנזקציות אוטומטי**: העלאת תמונות של קבלות, חשבוניות או מסמכי PDF, והמערכת תזהה ותחלץ אוטומטית את פרטי העסקה (סכום, תאריך, ספק, קטגוריה) ותיצור תנועה חדשה. זה יחסוך זמן רב בהזנת נתונים ידנית.

- **סידור אוטומטי לקטגוריות**: AI שימיין אוטומטית תנועות לקטגוריות המתאימות על בסיס תיאור העסקה, ספק, או דפוסי הוצאה קודמים של המשתמש. המשתמש יוכל לאשר או לתקן את הסיווג.

- **צ'אטבוט חכם**: ממשק שיחה (chat) עם AI שיאפשר:
  - שאלות על מצב החשבון: "כמה הוצאתי החודש על מזון?" או "מה יתרת המעשר שלי?"
  - שאלות הלכתיות כלליות: "מה הדין עם מעשר מהכנסה פטורה?"
  - המלצות: "לפי ההוצאות שלך, כדאי לך לבדוק את הקטגוריה X"
  - ניתוח מגמות: "ההוצאות שלך על Y גדלו ב-20% החודש"

#### 3. המרת מטבעות בזמן אמת

פיצ'ר המרת מטבעות מלא עם שערי חליפין מעודכנים בזמן אמת. המשתמש יוכל:

- להמיר סכומים בין מטבעות שונים (שקל, דולר, אירו)
- לראות את יתרת המעשר במטבע מועדף, גם אם התנועות במטבעות שונים
- לקבל עדכונים אוטומטיים על שערי חליפין
- לשמור היסטוריית שערים לצורך דוחות רטרואקטיביים

- **דוחות וניתוחים מתקדמים**: גרפים אינטראקטיביים, מגמות לאורך זמן, השוואות תקופתיות, וניתוח התפלגות הוצאות לפי קטגוריות. דוחות שנתיים אוטומטיים שיכולים לשמש גם למס הכנסה.

בסיכומו של דבר, מנקודת ראות של מנהל מוצר Ten10 מצטייר כפיתרון הוליסטי לניהול כספי הבית עבור הציבור הרחב ובפרט לציבור שומר מצוות: הוא משלב פשטות שימוש עם עומק פונקציונלי רלוונטי (מעשר), נותן מענה גם ללא אינטרנט, ומציג מקצועיות ועדכניות טכנולוגית – כל זאת בקוד פתוח שניתן להרחבה ושיפור מתמיד.

## מנקודת מבט של מפתח תוכנה

מבחינה טכנולוגית, Ten10 נבנה כיישום React מודרני בשפת TypeScript, עם דגש על ארכיטקטורה חוצה-פלטפורמות. כלומר, אותו בסיס קוד רץ הן כספא (Single Page Application) בווב, והן כאפליקציית Desktop באמצעות מעטפת Tauri (המשלבת מנוע Webview עם יכולות שפת Rust)[^20]. הגישה הזו מאפשרת שיתוף מרבי של לוגיקה ורכיבים בין הגרסאות – רוב הקוד של הממשק, הניהול והחישובים זהה – ורק חלקי הקוד של שכבת הנתונים מותאמים לפלטפורמה (שמירה ב-Supabase לעומת SQLite)[^21]. הודות לכך, חוויית המשתמש ועץ המסכים דומים מאוד בין ווב לדסקטופ, וההבדלים הטכניים מוסתרים מאחורי הקלעים.

אחד המרכיבים המרכזיים במימוש הוא Store גלובלי המבוסס על Zustand (ספריית state management פשוטה ויעילה ל-React)[^22]. במודל של Ten10, כל העסקאות הפיננסיות של המשתמש נטענות אל מבנה מערכי בעבודה (transactions: Transaction[]) שנשמר בזיכרון ב-Zustand. כל פעולה של המשתמש בממשק – הוספת עסקה, עריכה או מחיקה – מעודכנת תחילה ב-Store הפנימי, ומיד לאחר מכן מתPersistת לאחסון הקבוע (בסיס הנתונים) דרך שירותי נתונים ייעודיים[^23]. גישה זו מאפשרת חוויית שימוש חלקה ומהירה: המשתמש רואה מייד את העדכון בממשק (כי המידע כבר בעץ הזיכרון), תוך שהשמירה לבסיס הנתונים מתרחשת ברקע באופן אסינכרוני.

### תהליך הוספת עסקה – זרימת נתונים

מה קורה כאשר משתמש מוסיף עסקה חדשה? התרשים הבא ממחיש את הזרימה, בגרסת הווב ובגרסת הדסקטופ במקביל:

```
תרשים: תהליך הוספת עסקה ב-Ten10
המשתמש ממלא טופס ב-UI (React)
↓
ה-Store מעודכן מיד
↓
ב-Web: קריאת Insert ל-Supabase (Postgres)
ב-Desktop: פקודת Rust לכתיבה ל-SQLite
↓
עדכון תצוגת הדשבורד עם הנתונים החדשים
```

כמו שמוצג לעיל, בעת לחיצה על "שמירה" בטופס העסקה, רכיב הטופס יוצר אובייקט Transaction חדש ומעביר אותו לשכבת השירות. כאן מתרחש פיצול לוגי בהתאם לפלטפורמה:

- **בגרסת הווב** – הקוד קורא ל-API של Supabase כדי להכניס שורה חדשה לטבלת transactions בבסיס הנתונים בענן. הקריאה מתבצעת באמצעות SDK של Supabase בצד הלקוח, יחד עם מזהה המשתמש המחובר (כדי לשייך את העסקה למשתמש הנכון)[^24][^25]. מנגנון אבטחת Row Level Security בדטאבייס מבטיח שמשתמש יוכל לקרוא ולעדכן רק את הרשומות של עצמו[^26].

- **בגרסת הדסקטופ** – הקריאה היא לפונקציה בגב Rust (דרך מנגנון Tauri Invoke). למעשה מתבצעת פקודה add_transaction שנכתבה ב-Rust, אשר פותחת את מסד ה-SQLite המקומי וכותבת אליו את פרטי העסקה החדשה[^27][^28].

לאחר ההכנסה לבסיסי הנתונים, המערכת מעדכנת סימן זמן אחרון-טעינה כדי ליידע את האפליקציה שיש לרענן את רשימת העסקאות מהשרת/דטהבייס[^29][^30]. בפועל, כיום Ten10 משתמשת בגישה פשוטה של טעינה מחדש: אחרי כל שינוי (הוספה/עדכון/מחיקה), האפליקציה קוראת שוב את כל רשימת העסקאות מהמקור (Supabase או SQLite) ומעדכנת את ה-Store בהתאם. גישה זו מבטיחה סנכרון מלא בין המצב המקומי למצב בבסיס הנתונים[^23]. בעתיד, ניתן לשפר זאת עם מנגנוני עדכון אינקרמנטליים או התראות בזמן-אמת (למשל יכולות live subscriptions של Supabase), אך בממדי הנתונים הנוכחיים הקריאה המחודשת אינה מכבידה ומהווה פתרון אמין.

בנוסף לתהליך יצירת עסקה, ישנם תהליכים דומים למחיקת עסקה או עריכתה: גם בהם הלוגיקה בודקת את הפלטפורמה, ובווב שולחת בקשת DELETE/UPDATE ל-Supabase (על הטבלה הרלוונטית), ובדסקטופ מפעילה פונקציית Rust שמבצעת SQL מתאים (DELETE/UPDATE) על בסיס הנתונים המקומי[^31][^32]. לאחר כל שינוי כאמור, מתרענן ה-Store וה-UI מתעדכן אוטומטית.

### הוראות קבע (Recurring Transactions) – ארכיטקטורה ומימוש

הוראות קבע הן אחד הפיצ'רים המורכבים יותר מבחינה ארכיטקטונית, ומדגימות את הגמישות של המערכת. המערכת משתמשת במודל **Template → Scheduler → Materialized Transactions**:

**מבנה הנתונים:**

- **טבלת `recurring_transactions`**: מאחסנת את ההגדרות (templates) של הוראות הקבע, כולל תדירות, יום בחודש, סכום, סוג תנועה וכו'. הטבלה קיימת גם ב-Supabase (ווב) וגם ב-SQLite (דסקטופ), עם סכימה זהה.
- **טבלת `transactions`**: מאחסנת את התנועות בפועל. כל תנועה שנוצרה מהוראת קבע מקושרת לתבנית המקורית דרך `source_recurring_id`, ונושא `occurrence_number` שמציין את מספר הביצוע (למשל 3 מתוך 12).

**תהליך ה-materialization:**

- **בווב**: CRON Job (Scheduled Function) רץ בסופבייס כל לילה ומבצע:

  1. שולף את כל הוראות הקבע הפעילות (`status = 'active'`) שהגיע תורן (`next_due_date <= CURRENT_DATE`)
  2. בודק עבור כל תבנית אם כבר קיימת תנועה עם אותו `source_recurring_id` ותאריך, כדי למנוע כפילויות
  3. מייצר תנועות חדשות בטבלת `transactions` עם כל הפרטים מהתבנית
  4. מעדכן את התבנית: מגדיל `execution_count`, מחשב את `next_due_date` הבא (למשל +1 חודש), ומסמן `status = 'completed'` אם הגיע למספר הביצועים המקסימלי

- **בדסקטופ**: תהליך שרת רץ בעת פתיחת האפליקציה (בפונקציית Rust) ומבצע לוגיקה דומה:
  1. "מסתכל אחורה" מה-`last_run` (או `start_date` אם זו הפעם הראשונה) עד היום
  2. מחשב אילו תנועות היו אמורות להיות מיוצרות בתקופה הזו לפי התדירות
  3. מייצר את התנועות החסרות ל-SQLite, תוך בדיקה שהן לא קיימות כבר

**אתגרים טכניים:**

- **אטומיות**: הפונקציה ב-Supabase רצה בתוך טרנזקציה SQL, מה שמבטיח שאם ה-INSERT מצליח אבל ה-UPDATE נכשל, הכל מתבטל. זה מונע מצבים של תנועות ללא עדכון התבנית.
- **חישוב תאריכים מורכב**: מה קורה אם `day_of_month` הוא 31 והחודש הבא הוא פברואר? מנגנון ה-`INTERVAL` של PostgreSQL (ו-Rust date libraries) מתמודד עם זה אוטומטית.
- **מניעת כפילויות**: כל תנועה שנוצרה מהוראת קבע נבדקת לפני יצירה, כדי למנוע יצירת תנועות כפולות אם התהליך רץ פעמיים.

זהו דוגמה מצוינת לארכיטקטורה מודולרית: הקומפוננטות ב-React אינן צריכות לדעת איך נוצרות התנועות – הן פשוט קוראות את `transactions[]` מה-Store, והתהליכים ברקע דואגים ליצור אותן.

### חישוב יתרת המעשר – לוגיקה עסקית

מעשר כספים הוא לב המערכת, ועל המפתח להבין כיצד מחושבת יתרת המעשר הנדרשת בכל עת. החישוב מבוסס על סכום כל העסקאות שהוזנו, לפי כללים עסקיים פשוטים:

```
תרשים: השפעת סוגי עסקאות על חישוב יתרת המעשר

הכנסות רגילות:
  - מוסיפות 10% מהסכום ליתרת המעשר
  - או 20% אם מוגדר כחומש

תרומות:
  - מקטינות את היתרה בסכום מלא (100%)

הוצאות מיוחדות המותרות מתרומות:
  - מקטינות 100% מהסכום

סוגי הכנסה פטורה והוצאה רגילה:
  - אינם משנים את היתרה (0%)
```

כפי שמודגם לעיל ובדרישות המערכת, האפליקציה מבחינה בין מספר סוגי עסקאות מבחינת השפעתן על חוב המעשר[^9]:

- **הכנסה רגילה** (לדוגמה: משכורת) – מגדילה את חוב המעשר ב-10% מסכום ההכנסה. המשתמש יכול גם לסמן שההכנסה תחושב לפי "חומש" (20%), ואז 20% מהסכום יתווסף במקום 10%[^33]. ישנם סוגי הכנסות שסומנו פטורות ממעשר (כגון החזר הוצאות) שאינן משפיעות כלל, כלומר 0%.

- **תרומה/צדקה** – מפחיתה את חוב המעשר בסכום מלא השווה לתרומה (100%). כלומר, אם המשתמש תרם 100 ש"ח, יתרת המעשר שצריך לשלם קטנה ב-100 ש"ח[^33].

- **הוצאה רגילה** – אינה משפיעה (המשתמש אמנם הוציא כסף אך לא קשור למעשר, 0%).

- **הוצאה מיוחדת המותרת ממעשר** – אלו הוצאות על צורכי דת או רוח המותרות לתשלום מכספי מעשר (למשל עזרה ללימוד תורה, צדקה עקיפה). הוצאה כזו מפחיתה את חוב המעשר, שכן היא נחשבת כאילו שולמה מכספי המעשר[^34]. סכום ההוצאה מקטין את היתרה (100% מהסכום).

החישוב מבוצע גם בצד הלקוח (ב-JavaScript, באמצעות selector ממומואיז של Zustand) לטובת תגובתיות מיידית[^22], אך גם ממומש בצד השרת הן בענן והן בדסקטופ:

- **בווב** – בסיס הנתונים ב-Supabase כולל פונקציות SQL (Stored Procedures) שמחשבות את סכומי המעשר והסיכומים האחרים ישירות במסד[^21]. למשל פונקציה calculate_user_tithe_balance(user_id) מחזירה את חוב המעשר הכולל למשתמש, תוך שהיא מיישמת את הלוגיקה שלעיל בשאילתת SQL. פונקציות נוספות מחשבות סך הכנסות, סך תרומות וכדומה.

- **בדסקטופ** – במודול ה-Rust קיימות פונקציות מקבילות (כמו get_desktop_overall_tithe_balance) שרצות על מסד ה-SQLite המקומי ומבצעות שאילתות SQL לחישוב אותם ערכים[^21].

בעת טעינת המסך, האפליקציה פונה לשרת (או ל-Rust) לקבלת הערכים המחושבים ומציגה אותם למשתמש. כרגע המערכת אף מציגה במקביל את הערך המחושב בצד הלקוח לשם אימות, אך עם התבססות הלוגיקה בצד שרת, החישוב הלקוח מיועד בהמשך לשמש כגיבוי בלבד[^21][^35]. עבור המפתח, פירוש הדבר הוא ששמירת עקביות הלוגיקה קריטית: כל שינוי בהגדרות חישוב המעשר צריך להתעדכן הן בפונקציות השרת (SQL/Rust) והן בקוד הלקוח (JavaScript) עד לאיחוד המלא של מנגנון החישוב בצד אחד. המאמץ הזה שווה את ההשקעה מכיוון שחישוב בצד השרת מאפשר מהירות ודיוק עבור כמויות גדולות של נתונים, ומבטיח שכל משתמש יראה את אותם ערכים גם אם ייגש דרך מכשיר אחר (באותו חשבון ווב).

### מבט על פיתוח ותחזוקה

Ten10 בנוי עם סט כלים עדכני, מה שמקל על המפתח הן בהרחבת הפיצ'רים והן בתחזוקה השוטפת:

- **פרונטנד ב-React 18** עם בנייה באמצעות Vite – מה שמאפשר פיתוח מודולרי וטעינה מהירה[^36]. הניווט הפנימי מתבצע עם TanStack Router לספא, במקום שימוש ב-React Router הקלאסי[^37], כדי ליהנות מיכולות ניתוב מודרניות.

- **עיצוב הממשק** משתמש בסטייל Tailwind CSS ובספריית רכיבים shadcn/ui הבנויה על Radix – כך שהמפתח כותב מינימום CSS ידני ונהנה מרכיבים נגישים ומעוצבים מראש[^38]. למשל, טפסים, מודאלים, טבלאות וגרפים – רובן הורכבו מרכיבי ספרייה עם התאמות קלות, תוך שמירה על מראה אחיד.

- **ניהול ה-state הגלובלי** מתבסס כאמור על Zustand – ספרייה קלילה המאפשרת יצירת store מחוץ ל-React ולצרוך נתונים ממנו בקלות בתוך קומפוננטות[^22]. מצב האפליקציה (רשימת העסקאות, ההעדפות, המצב המחושב וכו') מרוכז במקום אחד, מה שמקל על ניפוי שגיאות והוספת יכולות (לדוגמה, מימוש Undo/Redo עתידי אפשרי ע"י שמירת היסטוריית שינויים ב-store).

- **לטיפול בטפסים ובאימות קלט המשתמש**, נעשה שימוש ב-React Hook Form יחד עם Zod לבניית סכימת אימות[^39]. משמעות הדבר היא שהמפתח מגדיר באופן דקלרטיבי אילו שדות טופס מצופים ואיזה מבנה נתונים תקין, והספריות הללו דואגות לוולידציה אוטומטית (כולל הודעות שגיאה בשפות השונות). זה הפחית משמעותית כתיבת קוד אימות ידני ושיפר את אמינות התוכנה – משתמש לא יכול לשמור עסקה עם שדות חסרים או ערכים בפורמט לא תקין.

- **המערכת תומכת בריבוי שפות** באמצעות i18next: כל הטקסטים מופרדים בקבצי JSON תחת public/locales עבור כל שפה[^15]. הפתרון הזה מקל על המפתח להוסיף שפות (רק לתרגם את קובץ המחרוזות) ומוודא שכל הממשק מתעדכן אוטומטית בהתאם לשפה הנבחרת. בנוסף, היישום מזהה אוטומטית שפה RTL (עברית) ומחליף לכיוון ימין-שמאל באמצעות הגדרות CSS מתאימות.

- **כתיבת הקוד ב-TypeScript** יחד עם שימוש עקבי ב-types (מוקלד עבור אובייקט Transaction, עבור שירותי הנתונים וכו') מונעים הרבה שגיאות בזמן קומפילציה. הקפדה על טיפוסי נתונים, במיוחד במעברים בין JavaScript ל-Rust (בקריאות invoke של Tauri), נתנה ביטחון שאובייקט העסקה נשלח בשלמותו ומתקבל במבנה הצפוי גם בצד השני.

- **לבסוף, המפתח נהנה מתשתית CI/CD** מפותחת: פרויקט Ten10 משתמש ב-GitHub Actions אוטומטיים ובכלי Dependabot כדי לעדכן תלויות ספרייה באופן שוטף[^40]. תהליך ההפצה כולל:
  - **הפצת ווב**: כל push ל-main או tag מתאים מפעיל workflow שבונה את ה-frontend (Vite) ומפריס אוטומטית ל-Vercel או פלטפורמת hosting אחרת. ה-build כולל אופטימיזציות, minification ו-bundling אוטומטי.
  - **הפצת דסקטופ**: כאשר נוצר tag בגרסה (למשל `v0.3.0`), GitHub Actions מריץ workflow שמבצע:
    1. Build של ה-frontend (Vite)
    2. Build של אפליקציית Tauri (Rust + bundling)
    3. חתימה על installers עם Tauri signer (לאבטחה)
    4. יצירת GitHub Release עם קובצי ההתקנה (`.msi` ל-Windows)
    5. העלאת `latest.json` שמשמש את מנגנון העדכונים האוטומטיים
  - **תחזוקת תלויות**: Dependabot בודק באופן שוטף עדכוני אבטחה ותיקוני באגים לספריות, ויוצר Pull Requests אוטומטיים. בנוסף, קיימים מדריכי פיתוח מפורטים בתיקיית llm-instructions – הכוללים הסברים על שמירת נתונים בדסקטופ, ארכיטקטורת context לפלטפורמות, תמיכה בריבוי שפות ועוד[^41] – כך שגם מפתח חדש המצטרף לצוות יכול ללמוד את המערכת במהירות.

לסיכום חלק זה, מנקודת מבט הפיתוח Ten10 מדגימה איך ניתן לבנות אפליקציה פיננסית מלאה עם כלי Web מודרניים: היא ממנפת BaaS (כמו Supabase) כדי לחסוך בפיתוח צד-שרת, משלבת יכולות אופליין דרך Tauri/Rust ללא כתיבת לוגיקה כפולה, ומשתמשת בפרקטיקות פיתוח טובות (הפרדת אחריות, אימות נתונים, state management יעיל). כל זאת מאפשרת לפיתוח להתמקד בפתרון הבעיה העסקית (ניהול מעשר) ולא בבניית תשתיות מאפס.

## מנקודת מבט של ארכיטקט תוכנה

ארכיטקטורת המערכת של Ten10 תוכננה לתת מענה למספר אתגרים: תמיכה בכמה פלטפורמות (Web ודסקטופ) עם בסיס קוד יחיד, יכולת עבודה אופליין מלא לצד שימוש בענן, ואבטחת נתונים אישיים במודל התואם אפליקציה פיננסית.

```
תרשים: ארכיטקטורת Ten10

מימין - גרסת ה-Web:
  אפליקציית React בדפדפן (PWA + TWA)
  ↓
  שירות Supabase (API, אימות, Postgres בענן)
  ↓
  AWS SES (שליחת מיילים)

משמאל - גרסת הדסקטופ:
  אפליקציית React ארוזה ב-Tauri (רצה מקומית)
  ↓
  שכבת Rust
  ↓
  מסד נתונים SQLite מקומי

הערה: קיים סנכרון ידני בין הפלטפורמות באמצעות ייבוא/ייצוא JSON.
```

חלוקת האחריות במערכת ברורה: צד הלקוח (Front-End) מטפל בכל מה שהמשתמש רואה ועושה, וצד השרת/מסד (Back-End) אחראי לאחסון הנתונים ולחישובים המרכזיים. גרסת ה-Web מתבססת על סביבת שרת מוכנה (Supabase) במקום לפתח שרת ייעודי מאפס. Supabase מספקת מסד נתונים Postgres מנוהל עם API חשוף, וכן שירותי משתמשים (הרשמה, אימות OAuth וכו') – דבר שצמצם משמעותית את זמן הפיתוח ואפשר לארכיטקט להתמקד בלוגיקת האפליקציה[^2]. הנתונים ב-Supabase מוגנים על-ידי מדיניות Row-Level Security, כך שגם אם כל התקשורת היא ישירות מהמובייל/דפדפן לדאטאבייס, אין סכנה שמשתמש יראה נתונים של אחר (המסד בודק כל שאילתה לפי מזהה משתמש ומחזיר רק את הרשומות שלו)[^26]. זה פתרון אלגנטי לאבטחה מבלי להקים שרת מתווך.

במקביל, גרסת הדסקטופ משתמשת במסד SQLite מקומי (קובץ Ten10.db) המאוחסן אצל המשתמש[^26]. בחירה ב-SQLite מאפשרת שימוש ביכולות רלציוניות (טבלאות, שאילתות SQL מורכבות) גם ללא שרת, ומספקת מהירות גבוהה עבור נפחי נתונים קטנים-בינוניים. שכבת ה-Rust של Tauri פועלת כמעין "שרת מקומי" שמאזין לקריאות מה-front-end ומבצע את הפעולות על ה-SQLite (קריאות SELECT/INSERT/UPDATE וכד')[^21]. החלטה ארכיטקטונית זו – לנצל את Rust עבור הגישה לדיסק – תורמת לביצועים ולאבטחה: Rust היא שפה קומפילטיבית ובטוחה (memory-safe), מה שמבטיח גישה יעילה למסד הנתונים המקומי ללא חשש לדליפות זיכרון או קריסות בלתי צפויות. בנוסף, כל הקוד הרגיש (קריאה/כתיבה למערכת הקבצים) מוגבל לצד ה-Rust, וה-UI (JavaScript) אינו יכול לגשת ישירות לדיסק, מה שמונע מניפולציה לא מורשית של הקבצים.

הארכיטקטורה מדגישה מודולריות: חלקי המערכת מחולקים בצורה לוגית כך שניתן להחליפם או לשנותם בלי להשפיע זה על זה. למשל, כל פעולות ה-CRUD על עסקאות מבודדות בשכבת data-layer עם פונקציות שירות אחידות (addTransaction, loadTransactions וכו'), שבתוכן מתבצע ההיגיון אם לפנות ל-Supabase או ל-SQLite[^27][^42]. לכן, הקומפוננטות ב-React אינן "יודעות" היכן הנתונים נשמרים בפועל – הן קוראות לפונקציות שירות, ומקבלות/שולחות אובייקטי Transaction. אם בעתיד יוחלט להוסיף סנכרון או לשנות אחסון (נניח, להשתמש בIndexedDB בדפדפן או בענן אחר), ניתן לעשות זאת בשכבה הזו מבלי לשנות את כלל הממשק. דוגמה נוספת: רכיב זיהוי הפלטפורמה (Platform Context) נטען פעם אחת בעת עליית האפליקציה, ומאפשר לכל שאר הקוד פשוט לבדוק אם platform === "web" או "desktop" כדי להחליט על UI שונה או לוגיקה שונה במידת הצורך[^43]. כך למשל מסך פרופיל המשתמש נטען רק בווב (כי בדסקטופ אין משתמש רשום), או כפתורי גיבוי הנתונים מופיעים רק בדסקטופ[^16]. ההחלטות הללו מתקבלות באופן ריכוזי דרך הקונטקסט, ולא מפוזרות כבדיקות בכמה מקומות – מה ששומר על קוד נקי וברור.

### סט הטכנולוגיות

סט הטכנולוגיות שבחרנו עבור Ten10 נועד לתמוך בדרישות אלו של גמישות ושיתוף קוד. להלן רכיבי ה-Stack המרכזיים בארכיטקטורה[^36]:

- **שפת תכנות עיקרית**: TypeScript (גם לפרונטנד וגם להרצת לוגיקה משותפת). בנוסף, שפת Rust משמשת למודול הדסקטופ. הבחירה ב-TypeScript מבטיחה טיפוסיות חזקה בצד הלקוח, והבחירה ב-Rust לדסקטופ מבטיחה ביצועים ובטיחות זיכרון בצד השרת המקומי.

- **Front-End**: ספריית React (גרסה 18) המשולבת עם בנדלר Vite. React מעניקה את כל היתרונות של ספריית UI פופולרית – קומפוננטות, וירטואל DOM, אקו-סיסטם גדול – ו-Vite מספקת פיתוח מהיר (HMR) ובנייה יעילה לפרודקשן.

- **Back-End לענן**: שירות Supabase (הכולל PostgreSQL + Auth + פונקציות Serverless) במקום לפתח שרת Node.js בעצמנו. החלטה זו תאמה את משאבי הצוות ורצון ה-product לספק פתרון מהיר עם הרשמה והתחברות נוחות, ללא התעסקות בניהול שרתים. Supabase מטפל גם בשליחת מיילים (לצורך אימות משתמשים ותזכורות) דרך הפונקציות שלו, ובכך משלים את כל צורכי הצד-שרת של המערכת[^17].

- **Desktop Container**: סביבת Tauri 2.0 – מסגרת המאפשרת לארוז אפליקציית ווב כיישום דסקטופ עצמאי. הבחירה ב-Tauri (על פני Electron לדוגמה) נבעה מכמה סיבות ארכיטקטוניות: Tauri כתוב ב-Rust ולכן מניב אפליקציות קלות ובטוחות יותר, הוא מאפשר ניצול ישיר של APIים של מערכת ההפעלה (כגון התראות, מנהל חלונות) בקלות, והוא משתלב היטב עם חבילות Node.js קיימות. בפועל, אפליקציית ה-Ten10 Desktop היא בינארי קטן יחסית, עם טביעת רגל זיכרון קטנה, שמקשר בין ממשק ה-React לבין מסד SQLite וכל שירותי OS נחוצים (כמו כתיבה/קריאה לקבצים, או בדיקת עדכונים).

- **מסדי נתונים**: PostgreSQL בענן (דרך Supabase) המשמש את כלל המשתמשים המקוונים – עם טבלאות transactions, users וכו'. מולו, SQLite מקומי לכל התקנת דסקטופ – לשימוש המשתמש הבודד. באופן אידאלי, סכימת בסיס הנתונים (DB schema) זהה בין שניהם[^44], מה שמקל על תחזוקת הקוד. לדוגמה, טבלת transactions קיימת בשניהם עם אותן עמודות, והלוגיקה יודעת לפנות לאותה טבלה בין אם זה קריאת SQL מקומית או באמצעות API בענן.

- **ניהול ושיתוף קוד**: הפרויקט מחולק כך שהקוד הייעודי ל-Web יושב תחת ספריית src/ (כל רכיבי ה-React, לוגיקת ה-Store וכו'), והקוד הייעודי לדסקטופ יושב תחת src-tauri/ (קוד Rust, קובץ הקונפיגורציה של Tauri, וסקריפטים כמו auto-updater)[^45][^46]. מכיוון שהפרונטנד משותף ברובו, הוא תוכנן לעבוד offline כשאפשר: לדוגמה, מסך ההתחברות (login) פשוט לא יוצג בדסקטופ, אך שאר המסכים (הגדרות, טפסי עסקאות, דוחות) עובדים בדסקטופ בדיוק כמו בווב, תוך קריאה לפונקציות Rust במקום ל-API מרוחק. החלוקה הזו איפשרה Reuse מקסימלי – קרוב ל-90% מהקוד המשויך לפיצ'רים עסקיים הוא משותף. רק שכבת הגישה לנתונים וההרשאות הוחלפה בהתאם, וכן רכיבים יחודיים (כמו כפתור "בדוק עדכונים" שיש רק בדסקטופ).

כארכיטקט, מעניין לציין כמה החלטות תכנון שנעשו כדי לתמוך בהתפתחות עתידית:

- ראשית, מודל הנתונים המאוחד (Transaction אחד לכל סוג) יאפשר להרחיב את סוגי התנועות או להוסיף קטגוריות ללא שבירת המבנה הקיים[^7].

- שנית, הבחירה לבצע חישובים כבדים במסד הנתונים (למשל סכומי יתרות לפי טווחי תאריכים) נועדה להבטיח ש-Ten10 יוכל לטפל בנפחי מידע גדולים יותר בעתיד ללא בעיות ביצועים – שאילתת SQL היא אופטימלית לזה, ורק התוצאה מגיעה ללקוח[^21]. במקביל, תכנון זה מאפשר בקלות להוסיף דוחות תקופתיים ומסכי ניתוח, על בסיס פונקציות SQL או View-ים נוספים במסד.

- שלישית, נושא העדכונים האוטומטיים בדסקטופ תוכנן כבר מהתחלה כדי למנוע פיצול גרסאות – המערכת בודקת ב-runtime אם יש עדכון, ומידעת את המשתמש או מורידה ברקע[^19]. כך אפשר לתקן באגים או להוסיף פיצ'ר ומיד כל המשתמשים (אפילו אופליין) מקבלים את הגרסה החדשה.

- לבסוף, תמיכה במובייל כבר קיימת: ה-Web App של Ten10 בנוי כ-PWA (Progressive Web App) מלא, וקיימת גם TWA (Trusted Web Activity) לאנדרואיד שנבנתה עם Bubblewrap. המשמעות היא שארכיטקטורת ה-frontend מופרדת מספיק מהפלטפורמה כדי לאפשר גם אפליקציה בטלפון חכם, עם אותם רכיבים. ה-TWA עדיין לא שוחרר ל-Play Store, אך הקוד קיים ומוכן.

### סיכום הארכיטקטורה

Ten10 מדגים עיצוב נקי שבו Client ו-Server (או מקבילו המקומי) עובדים בתיאום: ה-Client אחראי לחוויית משתמש וללוגיקה מיידית (ולידציה, הצגה, אינטראקציה), בעוד ה-Server (או Rust) מטפל בנתונים ובחישובים כבדים. הסנכרון בין המצב המקומי למצב השמורה בשרת מתבצע באופן יזום ושולט (fetch בעת הצורך)[^23], ואין "מצבים תלויים" שקשה לתחקות אחריהם. ארכיטקטורה זו גם מאפשרת Scalability – ניתן להריץ מספר מופעי שרת (Supabase) אם יהיו אלפי משתמשים, ללא שינוי בצד הלקוח, כי כל הלוגיקה שם מבוססת על קריאות API סטנדרטיות. הבדלה הברורה בין שכבות, שימוש בכלי פיתוח חזקים, ותיעוד מפורט הנלווה לקוד, כל אלו הופכים את Ten10 למערכת שעל אף מורכבות הדרישות (חישובים פיננסיים, תמיכה באופליין, ריבוי שפות) – היא ברורה, מתוחזקת היטב, ומוכנה להרחבה. העובדה שזהו פרויקט קוד פתוח מאפשרת לארכיטקטים ומפתחים נוספים להתעמק בקוד, ללמוד או לתרום, ולסייע בהפיכת Ten10 לכלי מוביל בנישה של ניהול מעשר וניהול פיננסי ביתי.

## מקורות

המידע והתיאורים נלקחו במלואם ממאגר הקוד הפתוח של הפרויקט (ריפוזיטורי GitHub) ומהתיעוד הפנימי שבו, כולל ה-README הרשמי של Ten10 ופירוט הדרישות והארכיטקטורה בקבצי התיעוד המצורפים[^1][^7] ועוד. כל האסמכתאות מסומנות בגוף הטקסט.

---

### הערות שוליים

[^1]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^2]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^3]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^4]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^5]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^6]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^7]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^8]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^9]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^10]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^11]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^12]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^13]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^14]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^15]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^16]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^17]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^18]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^19]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^20]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^21]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^22]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^23]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^24]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^25]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^26]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^27]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^28]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^29]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^30]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^31]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^32]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^33]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^34]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^35]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^36]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^37]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^38]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^39]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^40]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^41]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^42]: [transactions.service.ts](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/src/lib/data-layer/transactions.service.ts)
[^43]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^44]: [project-overview-and-requirements.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/llm-instructions/project-overview-and-requirements.md)
[^45]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
[^46]: [README.md](https://github.com/yossi-weinberger/ten10/blob/c9a53c974e43952c1423394e2046711acd3ec2ea/README.md)
